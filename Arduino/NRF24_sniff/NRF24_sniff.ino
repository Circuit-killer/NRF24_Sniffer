/*
  NRF24_Sniff - An Arduino sketch to promiscuous capture all wireless
                traffic generated by Nordic Semi. NRF24L01+ modules.

  Created by Ivo Pullens, Emmission, 2014 -- www.emmission.nl
  
  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/   
 
#include <Arduino.h>
#include <SPI.h>
#include <MyConfig.h>
#include <MySensor.h>
#include <CircularBuffer.h>
#include "utility/RF24.h"
#include "utility/RF24_config.h"

// Define some default values when MySensors library is not used
#ifndef RF24_CHANNEL
#define RF24_CHANNEL    76
#endif

#ifndef RF24_DATARATE
#define RF24_DATARATE   RF24_1MBPS
#endif

#ifndef BASE_RADIO_ID
#define BASE_RADIO_ID ((uint64_t)0xA8A8E1FC00LL) 
#endif

// Set up nRF24L01 radio on SPI bus plus pins 9 & 10
RF24 radio(9, 10);

#define PIPE               (0)                                                      // Pipe number to use for listening

#define RF_CHANNEL         (RF24_CHANNEL)                                           // Default channel for MySensors.
#define RF_DATARATE        (RF24_DATARATE)
#define RF_MAX_ADDR_WIDTH  (5)                                                      // Maximum address width, in bytes. MySensors use 5 bytes for addressing, where lowest byte is for node addressing.
#define RF_ADDR_WIDTH      (RF_MAX_ADDR_WIDTH-1)                                    // We use all but the lowest address byte for promiscuous listening. First byte of data received will then be the node address.
#define RF_PROMISC_ADDR    ((BASE_RADIO_ID)>>((RF_MAX_ADDR_WIDTH-RF_ADDR_WIDTH)*8)) // Our 'promiscuous' node address. BASE_RADIO_ID = Base address for MySensors.
#define RF_CRC_LENGTH      (2)                                                      // Length (in bytes) of NRF24 CRC
#define RF_PAYLOAD_SIZE    (32)                                                     // Define NRF24 payload size to maximum, so we'll slurp as many bytes as possible from the packet.
#define SER_BAUDRATE       (115200)
#define RF_IRQ_PIN         (2)
#define RF_IRQ             (RF_IRQ_PIN-2)                                           // Usually the interrupt = pin -2 (on uno/nano anyway)
#define PACKET_BUFFER_SIZE (30)                                                     // Maximum number of packets that can be buffered between reception by NRF and transmission over serial port.

// If BINARY_OUTPUT is defined, this sketch will output in hex format to the PC.
// If undefined it will output text output for development.
#define BINARY_OUTPUT

#include "NRF24_sniff_types.h"

// Macro to swap all bytes in 64bit value
#define BSWAP_64(x)     (((uint64_t)(x) << 56) | \
                        (((uint64_t)(x) << 40) & 0xff000000000000ULL) | \
                        (((uint64_t)(x) << 24) & 0xff0000000000ULL) | \
                        (((uint64_t)(x) << 8)  & 0xff00000000ULL) | \
                        (((uint64_t)(x) >> 8)  & 0xff000000ULL) | \
                        (((uint64_t)(x) >> 24) & 0xff0000ULL) | \
                        (((uint64_t)(x) >> 40) & 0xff00ULL) | \
                        ((uint64_t)(x)  >> 56))
                       
                       

#ifndef BINARY_OUTPUT
int my_putc( char c, FILE *t )
{
  Serial.write( c );
}
#endif

static NRF24_packet_t bufferData[PACKET_BUFFER_SIZE]; 
static CircularBuffer<NRF24_packet_t> packetBuffer(bufferData, sizeof(bufferData)/sizeof(bufferData[0]));
static Serial_header_t serialHdr;

static void handleNrfIrq()
{
  static uint8_t lostPacketCount = 0;
  // Loop until RX buffer(s) contain no more packets.
  while (radio.available())
  {
    if (!packetBuffer.full())
    {
      NRF24_packet_t* p = packetBuffer.getFront();
      p->timestamp = micros();  // Micros does not increase in interrupt, but it can be used.
      p->packetsLost = lostPacketCount;
      uint8_t packetLen = radio.getPayloadSize();
      if (packetLen > RF_PAYLOAD_SIZE)
        packetLen = RF_PAYLOAD_SIZE;
  
      radio.read( p->packet, packetLen );
      
      // Determine length of actual payload (in bytes) received from NRF24 packet control field (bits 7..2 of byte with offset 1)
      // Enhanced shockburst format is assumed!
      if (getPayloadLen(p) <= RF_PAYLOAD_SIZE)
      {
        // Seems like a valid packet. Enqueue it.
        packetBuffer.pushFront(p);
      }    
      else
      {
        // Packet with invalid size received. Could increase some counter...
      }
      lostPacketCount = 0;
    }
    else
    {
      // Buffer full. Increase lost packet counter.
      bool tx_ok, tx_fail, rx_ready;
      if (lostPacketCount < 255)
        lostPacketCount++;
      // Call 'whatHappened' to reset interrupt status.
      radio.whatHappened(tx_ok, tx_fail, rx_ready);
      // Flush buffer to drop the packet.
      radio.flush_rx();
    }
  }
}  


void setup(void)
{
  Serial.begin(SER_BAUDRATE);

#ifndef BINARY_OUTPUT
  fdevopen( &my_putc, 0);
  Serial.println("--- RF24_sniff ---");
#endif

  radio.begin();

  // Disable shockburst
  radio.setAutoAck(false);
  radio.setRetries(0,0);

  // Match MySensors' channel & datarate
  radio.setChannel(RF_CHANNEL);
  radio.setDataRate(RF_DATARATE);

  // Disable CRC & set fixed payload size to allow all packets captured to be returned by Nrf24.
  radio.disableCRC();
  radio.setPayloadSize(RF_PAYLOAD_SIZE);

  // Configure listening pipe with the 'promiscuous' address and start listening
  radio.setAddressWidth(RF_ADDR_WIDTH);
  radio.openReadingPipe(PIPE, RF_PROMISC_ADDR);
  radio.startListening();

#ifndef BINARY_OUTPUT
  radio.printDetails();
#endif

  // Attach interrupt handler to NRF IRQ output
  pinMode(RF_IRQ_PIN, INPUT);
  attachInterrupt(RF_IRQ, handleNrfIrq, FALLING);    // NRF24 Irq pin is active low.

  // Initialize serial header's address member to promiscuous address, with bytes reversed and highest address byte at lowest byte position.
  uint64_t addr = BSWAP_64(RF_PROMISC_ADDR) >> RF_ADDR_WIDTH*8;
  for (uint8_t i = 0; i < sizeof(serialHdr.address); ++i)
  {
    serialHdr.address[i] = addr;
    addr >>= 8;
  }
  
#ifndef BINARY_OUTPUT
  Serial.println("--- Listening... ---");
#endif
}

inline static void dumpData(uint8_t* p, int len)
{
#ifndef BINARY_OUTPUT
  while (len--) { printf("%02x", *p++); }
  Serial.print(' ');
#else
  Serial.write(p, len);
#endif
}
 
void loop(void)
{
  while (!packetBuffer.empty())
  {
    // One or more records present
    NRF24_packet_t* p = packetBuffer.getBack();
    serialHdr.timestamp   = p->timestamp;
    serialHdr.packetsLost = p->packetsLost;
    
    // Calculate data length in bits, then round up to get full number of bytes.
    uint8_t dataLen = (    (sizeof(serialHdr)<<3)                 /* Serial packet header */
                         + ((RF_MAX_ADDR_WIDTH-RF_ADDR_WIDTH)<<3) /* NRF24 LSB address byte(s) */
                         + 9                                      /* NRF24 control field */
                         + (getPayloadLen(p) << 3)                /* NRF24 payload length */
                         + (RF_CRC_LENGTH << 3)                   /* NRF24 crc length */
                         + 7                                      /* Round up to full nr. of bytes */
                      ) >> 3;                                     /* Convert from bite to bytes */

    // Write record length
    dumpData(&dataLen, sizeof(dataLen));
    // Write serial header
    dumpData((uint8_t*)&serialHdr, sizeof(serialHdr));
    // Write packet data
    dumpData(p->packet, dataLen-sizeof(serialHdr));

#ifndef BINARY_OUTPUT
    if (p->packetsLost > 0)
    {
      Serial.print(" Lost: "); Serial.print(p->packetsLost);
    }
    printf("\r\n"); 
#endif
    // Remove record as we're done with it.
    packetBuffer.popBack();
  }
}
// vim:cin:ai:sts=2 sw=2 ft=cpp1
